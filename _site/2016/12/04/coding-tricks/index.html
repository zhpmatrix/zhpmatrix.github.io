<DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>[Python]编程复盘</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="致力于算法，数据和工程的全链路打通">
    <link rel="canonical" href="http://localhost:4000/2016/12/04/coding-tricks/">
    <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="ZHPMATRIX blog posts" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <!-- Personal visit times -->
    <script>
	var _hmt = _hmt || [];
	(function() {
  		var hm = document.createElement("script");
  		hm.src = "//hm.baidu.com/hm.js?39e5930446e371d66d738fef008c3ce2";
  		var s = document.getElementsByTagName("script")[0]; 
  		s.parentNode.insertBefore(hm, s);
	})();
	</script>
 </head>


    <body>
    <header class="site-header">

  <div class="wrap">

    <div style="float:floate; margin-top:10px; margin-right:50px;"></div>
    <a class="site-title" href="/">ZHPMATRIX blog</a>
    <a class="site-title" href="/project.html">项目</a>
    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
</a>
      <div class="trigger">
        
          <a class="page-link" href="/about/">关于我</a>
        
          
        
          
        
      </div>
    </nav>
  </div>
  <!-- Personal visit times -->
  <script>
  var _hmt = _hmt || [];
  (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?39e5930446e371d66d738fef008c3ce2";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <style>
	body{background-color:#84bf97}
  </style>
 </header>


    <!--<div class="page-content" style="background-color:#F8F8FF;">-->
    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>[Python]编程复盘</h1>
    <p class="meta">Dec 4, 2016</p>
  </header>

  <article class="post-content">
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<p>这是利用Python做的第二个实践，第一个实践是2015年暑假在宁波智能制造产业研究院做Intern的时候写过一个八叉树的结构。问题描述如下：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/aba7d18bjw1faeoh2kq22j20lp0kedl9.jpg" alt="P" /></p>

<hr />

<p>代码基于Python，利用numpy做计算结构，matplotlib做绘图包，<strong>自己实现BP算法</strong>。根据问题描述，拟构建一个1xNx1的神经网络结构。在调研之后，基于Python的实现有keras，<a href="http://nezha.github.io/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/pybrain%E5%88%9D%E5%85%A5%E9%97%A8">pybrain</a>等，但是要求要自己Coding出BP模块。</p>

<p>为了充分利用numpy，将问题向量化，然后采用向量编程的想法来做，简单（统一的数据结构）且高效（numpy的执行效率）。很自然的，在Coding中选择的是Batch Learning方式，很多基于Matlab做的同学用的是Online Learning的方式。复盘之后的几个问题如下（是的，这篇复盘尽量不讨论关于BP的问题，仅仅是Coding问题）。</p>

<p><em>1.</em> numpy和matplotlib的极简使用？</p>

<p><em>list和array之间的关系</em>。例如，list和array之间的互相转换。这个问题中，需要认识到<strong>ndarray就是matrix</strong>，在C语言课程中，提到过的多维数组就是这个概念。很自然的，接下来就需要知道matrix相关的一些操作，包括行列操作,转置操作，范数操作等。在基本操作的基础上定义运算，如点积。关于运算，需要知道操作对象的属性，同样需要清楚针对对象中元素的运算过程，这是numpy的简单高效之处的体现之一。</p>

<p><em>关于array的合并与拆分</em>。在给定问题中，样本的输入是list结构，显然任务中存在着这样的需求，建立input和target的KV关系，因为这涉及到sampling操作。利用vstack合并操作可以实现我的目的，在上段内容中提到的行列操作则可以服务于split操作。</p>

<p><em>shuffle的使用</em>。在给定问题中，随机模块的使用需求有两个地方。第一个地方在于原来input是递增序列，在进行交叉集划分的时候需要shuffle。第二个地方在于同一个model，交叉验证的时候要对输入样本shuffle操作。通常算法中的shuffle操作可以从概率算法的角度给出一个解释，而结合神经网络模型阿狸说，每次shuffle都有自己的意义，此处不做讨论。</p>

<p><em>ndarray与matrix的关系</em>。在一些必要的时候，如果想利用numpy中的实现，特别是需要指定axis的时候，需要将我的数据转换为matrix格式，也就是np.mat()函数。利用在我的数据处理中，归一化的操作，利用MinMax操作，需要找到min和max值。</p>

<p><em>关于绘图</em>。对于绘图做了一个简单的封装，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def show(dat,xlabel,ylabel,title):
''' Showing one line'''
    plt.figure
    plt.plot(dat)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.show()
    plt.close()

def showLines(dat1,label1,dat2,label2,xlabel,ylabel,title):
''' Showing two lines'''
    plt.figure
    plt.plot(dat1, label=label1)
    plt.plot(dat2,label=label2)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    plt.legend()
    plt.show()
    plt.close()
</code></pre></div></div>

<p>在给定任务中，需要绘制三张图片，最简单的绘图方式应该就是这样了。</p>

<p><em>2.</em> 科学计算任务下，接口参数如何定义？</p>

<p>在给出理想的一个相对较粗的代码框架之前，来看几个细节。</p>

<p>一.关于<em>*args</em>和<em>**kwargs</em></p>

<p>二者都是可变参数，*args（arguments）表示任何多个<strong>无名参数</strong>，结构为tuple;</p>

<p>**kwargs(key words arguments)表示任意多个<strong>关键字参数</strong>，结构为dict;</p>

<p>举个栗子：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def foo(*args,**kwargs):
    print 'args=',args
    print 'kwargs=',kwargs
if __name__ == '__main__':
    foo(1,2,3,a = 1,b = 2) 结果为：

args=(1,2,3)
kwargs={'a':1,'b':2}
</code></pre></div></div>

<hr />

<p>吐槽时刻，读者可略过…</p>

<p>Python中有这样的一个用法，将函数作为另一个函数的参数传入并调用。就是这样的：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def func_a(*args):
    return args
def func_b(func,*args):
    print(func(*args))
if __name__ == '__main__':
    func_b(func_a,1,2,3)
</code></pre></div></div>

<p>与其那样，不如这样：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def func_a(*args):
    return args
def func_b(*args):
    print(func_a(*args))
if __name__ == '__main__':
    func_b(1,2,3) 如果真的是这样，上面还有什么意义呢？这样的好处是显而易见的，同样的输入参数，调用不同的函数结果不同(说了句废话...)。
</code></pre></div></div>

<p>二.函数参数传递</p>

<p>举两个栗子，我就可以什么也不用说了。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def func(x,y = 2,*p,**q):
    print 'x=',x
    print 'y=',y
    print 'p=',p
    print 'q=',q
if __name__ == '__main__':
    func(20,10,1,2,3,a = 4,b = 5)
</code></pre></div></div>

<p>输出结果为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x=20
y=10
p=(1,2,3)
q={'a':4,'b':5}
</code></pre></div></div>

<p>第二个栗子：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def func(x,y = 2)
    print 'x=',x
    print 'y=',y
if __name__ = '__main__':
    func(y = 10,x = 4)
</code></pre></div></div>

<p>输出结果为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x=4
y=10
</code></pre></div></div>

<p>所以，或许在传递参数的时候采用<strong>参数名加参数值</strong>的方式比较好，代码的可读性增强了。但是，并不意味着在函数定义的时候给定默认参数值不是一种好的方式，可能有的参数被码农同学经常使用的概率很小，但是作为程序友好，还是开放给码农同学。此外，函数实现之前的参数校验部分也是节省了一部分工作，比如参数类型和参数是否为空校验。</p>

<p>借此安利两个小习惯(不管你信不信，这两个习惯会让你的效率大大增加，你想不到的增速)：</p>

<p><em>1.</em> 读代码前，弄明白变量的意义。</p>

<p><em>2.</em> 读数学证明前，弄明白notation的意义。</p>

<p>下边给出一个比较粗的代码框架（重在结构和参数）：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class NeuralNetwork:
    def __init__(self,layers,activation='tanh'):
        if activation == 'logistic':
            self.activation = self.__logistic
        elif activation == 'tanh':
            self.activation = self.__tanh
        Initialize weights and biases.
    def __logistic(x):
        Code here
    def __tanh(x):
        Code here
    def fit(self,x,y,learning_rate=0.2,epoches = 1000):
        Code here
    def predict(self,x):
        Code here
</code></pre></div></div>

<p>比如说，这是一种可能的调用方式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import numpy as np
from BP import NeuralNetwork
nn = NeuralNetwork(layers=[2,4,1],activation='tanh')
x = np.array([[1,2],[3,2],[5,2]])
y = np.array([1,0,1,1])
nn.fit(x,y,learning_rate=0.1,epoches=400)
test = np.array([[3,4],[2,1],[5,4]])
for i in test:
    print(i,nn.predict(i))
</code></pre></div></div>

<p>在NeuralNetwork的定义中，将各种类型的激活函数定义为私有函数，因为激活函数只在训练阶段被使用。整理的过程分为初始化，训练或者成为拟合，预测三个过程。实际上learning_rate和epoches两个参数也可以放在初始化参数列表中，也就是类的构造函数中。但是如果放在构造函数中，实例化参数列表就会变得冗长。不管在哪个地方，这两个参数总要显式传入函数。</p>

<p>总结：神经网络的拟合效果好坏依赖于<strong>tuning</strong>，对于强经验依赖，没有严格数学理论支撑的参数似乎不是太好，期待有人能够从理论上给参数一个合理的解释。虽然这样，但是从大家把神经网络用于实际问题的反响来看，它是work的，因此并不能说它不漂亮。</p>

  </article>

  <!-- mathjax -->
  
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  </div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">

    <h2 class="footer-heading">ZHPMATRIX blog</h2>

    <div class="footer-col-1 column">
      <ul>
	 <li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTY2ODEzNA==&mid=2247484598&idx=1&sn=ffbf5407ffd399a591930023639b2560&chksm=fc740dffcb0384e9f8fd98446fb0279fff5d4660fa78aed349b2ae15b2192b037900f9d3943f&token=1310413677&lang=zh_CN#rd">微信公众号《KBQA沉思录》</a></li>
        <li><a href="mailto:zhpmatrix@gmail.com">Gmail邮箱</a></li> 
        <li><a href="https://weibo.com/u/2879902091">微博</a></li> 
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        <li>
          <a href="https://github.com/zhpmatrix">
            <span class="icon github">
              <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            <span class="username">zhpmatrix</span>
          </a>
        </li>
       </ul>
    </div>

    <div class="footer-col-3 column">
      <p class="text">致力于算法，数据和工程的全链路打通</p>
    </div>

  </div>
  
</footer>


    </body>
</html>
